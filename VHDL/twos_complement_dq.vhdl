-- generated by Digital. Don't modify this file!
-- Any changes will be lost if this file is regenerated.

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_1 is
  port (
    p_out: out std_logic;
    sel: in std_logic;
    
    in_0: in std_logic;
    in_1: in std_logic );
end MUX_GATE_1;

architecture Behavioral of MUX_GATE_1 is
begin
  with sel select
    p_out <=
      in_0 when '0',
      in_1 when '1',
      '0' when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity generate_gp is
  port (
    A_i: in std_logic;
    B_i: in std_logic;
    G_i: out std_logic;
    P_i: out std_logic);
end generate_gp;

architecture Behavioral of generate_gp is
begin
  G_i <= (A_i AND B_i);
  P_i <= (A_i OR B_i);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity full_adder is
  port (
    a: in std_logic;
    b: in std_logic;
    CarryIn: in std_logic;
    Result: out std_logic;
    CarryOut: out std_logic);
end full_adder;

architecture Behavioral of full_adder is
begin
  Result <= ((a XOR CarryIn) XOR b);
  CarryOut <= (((CarryIn AND a) OR (a AND b)) OR (CarryIn AND b));
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity adder_4bits is
  port (
    CarryIn: in std_logic;
    a_3: in std_logic;
    a_2: in std_logic;
    a_1: in std_logic;
    a_0: in std_logic;
    b_3: in std_logic;
    b_2: in std_logic;
    b_1: in std_logic;
    b_0: in std_logic;
    o_0: out std_logic;
    o_1: out std_logic;
    o_2: out std_logic;
    o_3: out std_logic;
    o_c: out std_logic);
end adder_4bits;

architecture Behavioral of adder_4bits is
  signal s0: std_logic;
  signal s1: std_logic;
  signal s2: std_logic;
  signal s3: std_logic;
  signal s4: std_logic;
  signal s5: std_logic;
  signal s6: std_logic;
  signal s7: std_logic;
  signal s8: std_logic;
  signal s9: std_logic;
  signal s10: std_logic;
begin
  gate0: entity work.generate_gp
    port map (
      A_i => a_3,
      B_i => b_3,
      G_i => s0,
      P_i => s1);
  gate1: entity work.generate_gp
    port map (
      A_i => a_2,
      B_i => b_2,
      G_i => s2,
      P_i => s3);
  gate2: entity work.generate_gp
    port map (
      A_i => a_1,
      B_i => b_1,
      G_i => s4,
      P_i => s5);
  gate3: entity work.generate_gp
    port map (
      A_i => a_0,
      B_i => b_0,
      G_i => s6,
      P_i => s7);
  gate4: entity work.full_adder
    port map (
      a => a_0,
      b => b_0,
      CarryIn => CarryIn,
      Result => o_0);
  s8 <= ((CarryIn AND s7) OR s6);
  s9 <= (s4 OR (s5 AND s6) OR (s7 AND s5 AND CarryIn));
  s10 <= (s2 OR (s3 AND s4) OR (s3 AND s5 AND s6) OR (s3 AND s5 AND s7 AND CarryIn));
  o_c <= (s0 OR (s2 AND s1) OR (s4 AND s1 AND s3) OR (s6 AND s1 AND s3 AND s5) OR (CarryIn AND s1 AND s3 AND s5 AND s7));
  gate5: entity work.full_adder
    port map (
      a => a_1,
      b => b_1,
      CarryIn => s8,
      Result => o_1);
  gate6: entity work.full_adder
    port map (
      a => a_2,
      b => b_2,
      CarryIn => s9,
      Result => o_2);
  gate7: entity work.full_adder
    port map (
      a => a_3,
      b => b_3,
      CarryIn => s10,
      Result => o_3);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity main is
  port (
    s_7: in std_logic;
    s_6: in std_logic;
    s_5: in std_logic;
    s_4: in std_logic;
    s_3: in std_logic;
    s_2: in std_logic;
    s_1: in std_logic;
    s_0: in std_logic;
    c_7: out std_logic;
    c_6: out std_logic;
    c_5: out std_logic;
    c_4: out std_logic;
    c_3: out std_logic;
    c_2: out std_logic;
    c_1: out std_logic;
    c_0: out std_logic);
end main;

architecture Behavioral of main is
  signal s0: std_logic;
  signal s1: std_logic;
  signal s2: std_logic;
  signal s3: std_logic;
  signal s4: std_logic;
  signal s5: std_logic;
  signal s6: std_logic;
  signal s7: std_logic;
  signal s8: std_logic;
  signal s9: std_logic;
  signal s10: std_logic;
  signal s11: std_logic;
  signal s12: std_logic;
  signal s13: std_logic;
  signal s14: std_logic;
begin
  s0 <= NOT s_6;
  s2 <= NOT s_5;
  s4 <= NOT s_4;
  s6 <= NOT s_3;
  s8 <= NOT s_2;
  s10 <= NOT s_1;
  s12 <= NOT s_0;
  gate0: entity work.MUX_GATE_1
    port map (
      sel => s_7,
      in_0 => s_6,
      in_1 => s0,
      p_out => s1);
  gate1: entity work.MUX_GATE_1
    port map (
      sel => s_7,
      in_0 => s_5,
      in_1 => s2,
      p_out => s3);
  gate2: entity work.MUX_GATE_1
    port map (
      sel => s_7,
      in_0 => s_4,
      in_1 => s4,
      p_out => s5);
  gate3: entity work.MUX_GATE_1
    port map (
      sel => s_7,
      in_0 => s_3,
      in_1 => s6,
      p_out => s7);
  gate4: entity work.MUX_GATE_1
    port map (
      sel => s_7,
      in_0 => s_2,
      in_1 => s8,
      p_out => s9);
  gate5: entity work.MUX_GATE_1
    port map (
      sel => s_7,
      in_0 => s_1,
      in_1 => s10,
      p_out => s11);
  gate6: entity work.MUX_GATE_1
    port map (
      sel => s_7,
      in_0 => s_0,
      in_1 => s12,
      p_out => s13);
  gate7: entity work.adder_4bits
    port map (
      CarryIn => s_7,
      a_3 => s7,
      a_2 => s9,
      a_1 => s11,
      a_0 => s13,
      b_3 => '0',
      b_2 => '0',
      b_1 => '0',
      b_0 => '0',
      o_0 => c_0,
      o_1 => c_1,
      o_2 => c_2,
      o_3 => c_3,
      o_c => s14);
  gate8: entity work.adder_4bits
    port map (
      CarryIn => s14,
      a_3 => '0',
      a_2 => s1,
      a_1 => s3,
      a_0 => s5,
      b_3 => '0',
      b_2 => '0',
      b_1 => '0',
      b_0 => '0',
      o_0 => c_4,
      o_1 => c_5,
      o_2 => c_6);
  c_7 <= s_7;
end Behavioral;
